"""
Dispute CRUD Operations
"""
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func, and_, or_, desc, asc
from sqlalchemy.orm import selectinload
from typing import List, Optional, Dict, Any, Tuple
from datetime import datetime, date, timedelta
from fastapi import UploadFile

from app.models.auth import User
from app.schemas.dispute import (
    DisputeCreate, DisputeUpdate, DisputeMessageCreate, DisputeResolutionCreate
)


class DisputeCRUD:
    """Dispute CRUD operations"""
    
    async def get_disputes(
        self,
        db: AsyncSession,
        user_id: int,
        skip: int = 0,
        limit: int = 20,
        status: Optional[str] = None,
        severity: Optional[str] = None,
        job_id: Optional[int] = None,
        raised_by_role: Optional[str] = None,
        search: Optional[str] = None
    ) -> Tuple[List[Dict[str, Any]], int]:
        """Get disputes with filtering"""
        # Mock data for now - replace with actual database queries
        disputes = []
        for i in range(1, 21):
            dispute = {
                "id": i,
                "job_id": 100 + (i % 10),
                "title": f"Quality Issue #{i}",
                "description": f"Description of dispute #{i}",
                "category": "quality",
                "severity": "medium" if i % 3 == 0 else "low",
                "status": "open" if i <= 5 else "resolved",
                "raised_by_id": 200 + i,
                "raised_by_role": "customer",
                "assigned_to_id": 300 + (i % 3) if i <= 10 else None,
                "customer_name": f"Customer {i}",
                "customer_email": f"customer{i}@example.com",
                "customer_phone": f"+1234567{i:04d}",
                "priority_score": 5 + (i % 5),
                "estimated_resolution_time": 24 + (i % 48),
                "photos": [f"/photos/dispute_{i}_1.jpg", f"/photos/dispute_{i}_2.jpg"],
                "documents": [],
                "resolution_type": "refund" if i > 15 else None,
                "resolution_summary": f"Resolved dispute #{i}" if i > 15 else None,
                "resolved_at": datetime.now() - timedelta(days=i) if i > 15 else None,
                "resolved_by_id": 400 + (i % 2) if i > 15 else None,
                "created_at": datetime.now() - timedelta(days=i * 2),
                "updated_at": datetime.now() - timedelta(days=i),
                "job_title": f"Paint Job #{100 + (i % 10)}",
                "job_address": f"123 Main St #{i}",
                "contractor_name": f"Contractor {i % 5 + 1}"
            }
            disputes.append(dispute)
        
        # Apply filters
        filtered_disputes = disputes
        if status:
            filtered_disputes = [d for d in filtered_disputes if d["status"] == status]
        if severity:
            filtered_disputes = [d for d in filtered_disputes if d["severity"] == severity]
        if job_id:
            filtered_disputes = [d for d in filtered_disputes if d["job_id"] == job_id]
        if raised_by_role:
            filtered_disputes = [d for d in filtered_disputes if d["raised_by_role"] == raised_by_role]
        if search:
            filtered_disputes = [d for d in filtered_disputes if search.lower() in d["title"].lower()]
        
        total = len(filtered_disputes)
        return filtered_disputes[skip:skip + limit], total
    
    async def create_dispute(
        self,
        db: AsyncSession,
        dispute_data: DisputeCreate,
        user_id: int
    ) -> Dict[str, Any]:
        """Create new dispute"""
        # Mock dispute creation - replace with actual database operations
        dispute_id = 999  # Would be generated by database
        
        return {
            "id": dispute_id,
            "job_id": dispute_data.job_id,
            "title": dispute_data.title,
            "description": dispute_data.description,
            "category": dispute_data.category,
            "severity": dispute_data.severity,
            "status": "open",
            "raised_by_id": user_id,
            "raised_by_role": "customer",  # Would be determined from user
            "customer_name": dispute_data.customer_name,
            "customer_email": dispute_data.customer_email,
            "customer_phone": dispute_data.customer_phone,
            "priority_score": 5,  # Would be calculated
            "photos": dispute_data.photos or [],
            "documents": dispute_data.documents or [],
            "created_at": datetime.now(),
            "updated_at": datetime.now()
        }
    
    async def get_dispute(self, db: AsyncSession, dispute_id: int) -> Optional[Dict[str, Any]]:
        """Get dispute by ID"""
        # Mock data - replace with actual database query
        if dispute_id == 999:  # Mock created dispute
            return {
                "id": 999,
                "job_id": 101,
                "title": "Test Dispute",
                "description": "Test dispute description",
                "category": "quality",
                "severity": "medium",
                "status": "open",
                "raised_by_id": 201,
                "raised_by_role": "customer",
                "created_at": datetime.now(),
                "updated_at": datetime.now()
            }
        return None
    
    async def user_has_dispute_access(
        self,
        db: AsyncSession,
        user_id: int,
        dispute_id: int
    ) -> bool:
        """Check if user has access to dispute"""
        # Mock access check - replace with actual logic
        return True
    
    async def user_can_edit_dispute(
        self,
        db: AsyncSession,
        user_id: int,
        dispute_id: int
    ) -> bool:
        """Check if user can edit dispute"""
        # Mock permission check - replace with actual logic
        return True
    
    async def update_dispute(
        self,
        db: AsyncSession,
        dispute_id: int,
        dispute_data: DisputeUpdate
    ) -> Dict[str, Any]:
        """Update dispute"""
        # Mock update - replace with actual database operations
        return {
            "id": dispute_id,
            "title": dispute_data.title or "Updated Dispute",
            "status": dispute_data.status or "open",
            "updated_at": datetime.now()
        }
    
    async def get_dispute_messages(
        self,
        db: AsyncSession,
        dispute_id: int
    ) -> List[Dict[str, Any]]:
        """Get dispute messages"""
        # Mock messages - replace with actual database query
        messages = []
        for i in range(1, 4):
            message = {
                "id": i,
                "dispute_id": dispute_id,
                "sender_id": 200 + i,
                "sender_name": f"User {i}",
                "sender_role": "customer" if i % 2 == 1 else "admin",
                "message": f"Message {i} for dispute {dispute_id}",
                "is_internal": False,
                "attachments": [],
                "created_at": datetime.now() - timedelta(hours=i)
            }
            messages.append(message)
        
        return messages
    
    async def add_dispute_message(
        self,
        db: AsyncSession,
        dispute_id: int,
        message_data: DisputeMessageCreate,
        user_id: int
    ) -> Dict[str, Any]:
        """Add message to dispute"""
        # Mock message creation - replace with actual database operations
        message_id = 999  # Would be generated by database
        
        return {
            "id": message_id,
            "dispute_id": dispute_id,
            "sender_id": user_id,
            "sender_name": "Current User",
            "sender_role": "customer",
            "message": message_data.message,
            "is_internal": message_data.is_internal,
            "attachments": message_data.attachments or [],
            "created_at": datetime.now()
        }
    
    async def upload_dispute_attachment(
        self,
        db: AsyncSession,
        dispute_id: int,
        file: UploadFile,
        description: Optional[str],
        user_id: int
    ) -> Dict[str, Any]:
        """Upload attachment to dispute"""
        # Mock file upload - replace with actual file handling and database operations
        attachment_id = 999  # Would be generated by database
        
        return {
            "id": attachment_id,
            "dispute_id": dispute_id,
            "filename": file.filename,
            "file_url": f"/attachments/dispute_{dispute_id}_{attachment_id}_{file.filename}",
            "file_type": file.content_type,
            "file_size": 1024,  # Mock size
            "description": description,
            "uploaded_by_id": user_id,
            "uploaded_at": datetime.now()
        }
    
    async def user_can_escalate_dispute(
        self,
        db: AsyncSession,
        user_id: int,
        dispute_id: int
    ) -> bool:
        """Check if user can escalate dispute"""
        # Mock permission check - replace with actual logic
        return True
    
    async def escalate_dispute(
        self,
        db: AsyncSession,
        dispute_id: int,
        escalation_reason: Optional[str],
        user_id: int
    ) -> bool:
        """Escalate dispute to higher authority"""
        # Mock escalation - replace with actual database operations
        return True
    
    async def resolve_dispute(
        self,
        db: AsyncSession,
        dispute_id: int,
        resolution_data: DisputeResolutionCreate,
        resolver_id: int
    ) -> bool:
        """Resolve dispute"""
        # Mock resolution - replace with actual database operations
        return True
    
    async def reopen_dispute(
        self,
        db: AsyncSession,
        dispute_id: int,
        reopen_reason: str,
        user_id: int
    ) -> bool:
        """Reopen resolved dispute"""
        # Mock reopen - replace with actual database operations
        return True
    
    async def get_dispute_statistics(
        self,
        db: AsyncSession,
        date_from: Optional[str] = None,
        date_to: Optional[str] = None
    ) -> Dict[str, Any]:
        """Get dispute statistics"""
        # Mock statistics - replace with actual database queries
        return {
            "total_disputes": 156,
            "open_disputes": 23,
            "resolved_disputes": 128,
            "escalated_disputes": 5,
            "low_severity": 89,
            "medium_severity": 52,
            "high_severity": 13,
            "critical_severity": 2,
            "category_breakdown": {
                "quality": 67,
                "payment": 34,
                "timeline": 28,
                "communication": 15,
                "materials": 8,
                "safety": 3,
                "other": 1
            },
            "average_resolution_time": 18.5,
            "resolution_rate": 82.1,
            "customer_satisfaction": 4.2,
            "monthly_trends": [
                {"month": "Jan", "total": 12, "resolved": 10},
                {"month": "Feb", "total": 15, "resolved": 13},
                {"month": "Mar", "total": 18, "resolved": 16},
                {"month": "Apr", "total": 22, "resolved": 19},
                {"month": "May", "total": 25, "resolved": 21},
                {"month": "Jun", "total": 23, "resolved": 20},
            ]
        }
    
    async def get_dispute_trends(
        self,
        db: AsyncSession,
        period: str = "month",
        limit: int = 12
    ) -> Dict[str, Any]:
        """Get dispute trends"""
        # Mock trends - replace with actual database queries
        trends = []
        for i in range(limit):
            trend = {
                "period": f"2024-{i+1:02d}",
                "total_disputes": 15 + (i % 10),
                "resolved_disputes": 12 + (i % 8),
                "average_resolution_time": 18.5 + (i % 5),
                "customer_satisfaction": 4.2 + (i % 3) * 0.1
            }
            trends.append(trend)
        
        return {
            "period": period,
            "trends": trends,
            "summary": {
                "total_disputes": sum(t["total_disputes"] for t in trends),
                "average_resolution_time": 18.5,
                "trend_direction": "improving"
            }
        }
    
    async def create_dispute_from_token(
        self,
        db: AsyncSession,
        job_token: str,
        issue_data: Dict[str, Any]
    ) -> Optional[Dict[str, Any]]:
        """Create dispute from job token (public endpoint)"""
        # Mock token validation and dispute creation
        # In real implementation, validate token and get job details
        if job_token == "mock-token-123":
            dispute_id = 998  # Would be generated by database
            
            return {
                "id": dispute_id,
                "job_id": 101,
                "title": issue_data.get("title", "Customer Issue"),
                "description": issue_data.get("description", "Issue reported by customer"),
                "category": issue_data.get("category", "other"),
                "severity": issue_data.get("severity", "medium"),
                "status": "open",
                "customer_name": issue_data.get("customer_name"),
                "customer_email": issue_data.get("customer_email"),
                "customer_phone": issue_data.get("customer_phone"),
                "created_at": datetime.now()
            }
        
        return None
    
    async def get_dispute_by_token(
        self,
        db: AsyncSession,
        dispute_id: int,
        token: str
    ) -> Optional[Dict[str, Any]]:
        """Get dispute details using public token"""
        # Mock token validation and dispute retrieval
        if token == "public-token-123":
            return {
                "id": dispute_id,
                "reference_number": f"DISP-{dispute_id:06d}",
                "title": "Customer Issue",
                "status": "open",
                "severity": "medium",
                "created_at": datetime.now() - timedelta(days=1),
                "last_updated": datetime.now(),
                "resolution_summary": None,
                "resolved_at": None,
                "messages": [
                    {
                        "id": 1,
                        "sender_name": "Customer Service",
                        "sender_role": "admin",
                        "message": "We have received your issue and are investigating.",
                        "created_at": datetime.now() - timedelta(hours=2)
                    }
                ]
            }
        
        return None


# Create instance
dispute_crud = DisputeCRUD()